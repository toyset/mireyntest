Задание 1.

Строго говоря, возможности использования ForkJoinPool сильно ограничены требованием минимизации (а в идеале - отсутствием) блокирующих операций. Но для данной задачи он подходит идеально. Константы EvaluatingTask.SURPLUS_THRESHOLD и EvaluatingTask.SIZE_THRESHOLD, определяющие гранулярность разбиения на подзадачи, должны быть скорректированы по результатам профилирования на "боевой" системе.

Также можно было:
1. сразу разбить задачу на N*X подзадач, где N - небольшое число (допустим 2-5);
2. вместо ForkJoinPool использовать ThreadPoolExecutor.

Чтобы узнать, какой и вариантов эффективнее, опять же, нужно профилировать на "боевой" системе.

Задание 2.

Самая простая (по сложности кода) реализация. Можно избавиться от рекурсии. Можно распараллелить, аналогично тому, как это сделано в предыдущем задании.
